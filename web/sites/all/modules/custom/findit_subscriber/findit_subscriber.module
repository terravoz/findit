<?php

/**
 * @file
 * Find It specific implementation of Subscriber Entity.
 */

/**
 * Implements hook_menu().
 */
function findit_subscriber_menu() {
  // Lookup and redirect to subscriber/* entities.
  $items['subscriber'] = array(
    'title' => 'Update or create a subscription',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('findit_subscriber_lookup_form'),
    'access callback' => TRUE,
  );
  // Subscription to nodes on FindIt.
  $items['subscription/%node'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('findit_subscriber_addedit_form', 1),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['subscription/confirm/%/%'] = array(
    'title' => 'Confirmation',
    'page callback' => 'findit_subscriber_confirm_page',
    'page arguments' => array(2),
    'access callback' => 'findit_subscriber_confirm_page_access',
    'access arguments' => array(2, 3),
  );
  return $items;
}

/**
 * Implements hook_voipscript_get_script_names().
 */
function findit_subscriber_voipscript_get_script_names() {
  return array(
    'findit_subscriber_receive_confirmation',
  );
}

/**
 * Implements hook_voipscript_load_script().
 */
function findit_subscriber_voipscript_load_script($script_name, $params = NULL) {
  if (!in_array($script_name, findit_subscriber_voipscript_get_script_names())) {
    return;
  }
  require_once dirname(__FILE__) . '/findit_subscriber.voipscripts.inc';
  return $script_name();
}

/**
 * Implements hook_mail().
 */
function findit_subscriber_mail($key, &$message, $params) {
  switch ($key) {
    case 'confirmation':
      return findit_subscriber_confirmation_mail($message, $params['url']);

    case 'event_notification':
      return findit_subscriber_event_notify_mail($message, $params['events']);

    case 'event_post_notification':
      return findit_subscriber_post_notify_mail($message, $params['node'], $params['action']);
  }
}

/****
 * Subscription: To a node
 *
 * Custom block and submit handler to allow for using same form to directly
 * subscribe to a node notifications using either mobile number or email.
 */

/**
 * Implements hook_block_info().
 */
function findit_subscriber_block_info() {
  $blocks['link'] = array(
    'info' => t('Subscription link'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function findit_subscriber_block_view($delta) {
  switch ($delta) {
    case 'link':
      return findit_subscriber_link_block();
  }
}

/**
 * Displays
 *
 * @return type
 */
function findit_subscriber_link_block() {
  $block = array();

  if (menu_get_item()['path'] != 'node/%') {
    return;
  }

  $node = menu_get_object();

  $block['content'] = array(
    '#theme' => 'link',
    '#text' => t('Sign up for @type reminder', array('@type' => $node->type)),
    '#path' => "subscription/$node->nid",
    '#options' => array(
      'attributes' => array(),
      'html' => FALSE,
    ),
  );

  return $block;
}

/**
 * Form constructor for subscription form.
 */
function findit_subscriber_addedit_form($form, &$form_state, $node) {
  drupal_set_title(t('__Reminder\'s Subscription__'));

  /*if ($node->type == 'event') {
    $title = t('Event reminder');
    $description = t('Enter your e-mail or mobile number to receive a reminder the day before this event.');
  }*/
  $form['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  $form['type'] = array(
    '#type' => 'value',
    '#value' => $node->type,
  );
 /* $form['subscriber_id'] = array(
    '#title' => $title,
    '#type' => 'textfield',
    '#size' => 15,
    '#description' => $description,
    '#required' => TRUE,
  );*/

  $form['subscribe_type'] = array(
    '#type' => 'radios',
    '#title' => t('How you would like to receive reminders for "@name"?', array('@name' => $node->title)),
    '#options' => drupal_map_assoc(array(t('Email'), t('SMS'))),
    );

  $form['subscriber_email'] = array(
    '#title' => 'Email',
    '#type' => 'textfield',
    '#size' => 15,
    '#description' => t('Enter your e-mail to receive a reminder the day before this event.'),
    '#required' => TRUE,
    '#element_validate' => array('findit_subscriber_email_validate')
  );

  $form['subscriber_phone'] = array(
    '#title' => 'Phone number',
    '#type' => 'textfield',
    '#size' => 10,
    '#description' => t('Enter your 10-digit phone number here to receive a reminder the day before this event.'),
    '#required' => TRUE,
    '#element_validate' => array('findit_subscriber_sms_validate')
  );


  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));
  return $form;
}

function findit_subscriber_email_validate($element, &$form_state, $form) {
  $value = $element['#value'];
  if (!valid_email_address($value)) {
    form_error($element, t('"%mail" is not a valid email address', array('%mail' => $value)));
  }
}

function findit_subscriber_sms_validate($element, &$form_state, $form) {
  $value = $element['#value'];
  if($error = findit_subscriber_validate_sms($value)) {
    form_error($element, $error);
  }
}

/**
 * Form validation handler for subscription form.
 *
 * @see findit_subscriber_addedit_form()
 */
function findit_subscriber_addedit_form_validate($form, &$form_state) {
  $subscriber_id = $form_state['values']['subscriber_id'];
  $type = findit_subscriber_detect_type($subscriber_id);
  if ($type == 'sms') {
    if($error = findit_subscriber_validate_sms($subscriber_id)) {
      form_set_error($field['field_name'] . '][' . $langcode . '][' . $delta . '][vnid', $error);
    }
    else {
      $form_state['values']['subscriber_id'] = $subscriber_id;
    }
  }
  else {
    if ($error = findit_subscriber_validate_email($subscriber_id)) {
      form_set_error('subscriber_id', $error);
    }
    else {
      $form_state['values']['subscriber_id'] = $subscriber_id;
    }
  }
}

/**
 * Form submission handler for subscription form.
 *
 * @see findit_subscriber_addedit_form()
 */
function findit_subscriber_addedit_form_submit($form, &$form_state) {
  $subscriber_id = $form_state['values']['subscriber_id'];
  $type = findit_subscriber_detect_type($subscriber_id);
  // Left as variable in case organization subscriptions return.
  $field = FINDIT_FIELD_SUBSCRIBER_EVENTS;

  if (empty($form_state['values']['subscriber_id'])) {
    drupal_set_message(t('An email address or mobile number is required.'));
    return;
  }

  if ($subscriber = entity_load('subscriber_entity', array($subscriber_id))) {
    $subscriber = reset($subscriber);
    $new = FALSE;
  }
  else {
    $subscriber = findit_subscriber_create($type, $subscriber_id);
    $new = TRUE;
  }

  // Add or remove.
  $addition = TRUE;
  if (!empty($subscriber->$field)) {
    foreach ($subscriber->{$field}[LANGUAGE_NONE] as $delta => $existing_values) {
      if ($existing_values['target_id'] == $form_state['values']['nid']) {
        $addition = FALSE;
        unset($subscriber->{$field}[LANGUAGE_NONE][$delta]);
      }
    }
  }
  if ($addition) {
    $subscriber->{$field}[LANGUAGE_NONE][] = array('target_id' => $form_state['values']['nid']);
  }

  if (subscriber_entity_access('revision')) {
    if ($addition) {
      drupal_set_message(t('Subscription added.'));
    }
    else {
      drupal_set_message(t('Subscription removed.'));
    }
  }
  else {
    if ($addition) {
      if ($new) {
        // If this is a new subscription first save a disabled subscription.
        // Then make an enabled revision that can be confirmed.
        $subscriber->{FINDIT_FIELD_SUBSCRIBER_ENABLED}[LANGUAGE_NONE][0]['value'] = 0;
        $subscriber->save();
        $subscriber->{FINDIT_FIELD_SUBSCRIBER_ENABLED}[LANGUAGE_NONE][0]['value'] = 1;
      }
      $subscriber->is_new_revision = TRUE;
      $subscriber->default_revision = FALSE;
      if ($new) {
        drupal_set_message(t('New subscription added. Please reply to message sent to confirm.'));
      }
      else {
        drupal_set_message(t('Existing subscription updated. Please reply to message sent to confirm.'));
      }
    }
    else {
      drupal_set_message(t('Subscription removed.'));
    }
  }

  $subscriber->changed = time();
  $subscriber->save();

  if (!subscriber_entity_access('revisions') && $addition) {
    $message = findit_subscriber_request_confirmation($subscriber);
    drupal_set_message($message);
  }
}

/****
 * Subscriber: Look-up, create and edit.
 *
 * A form to redirect to the subscriber entity edit form. Form alters
 * from the default entity edit for FindIt sms/email.
 */

/**
 * Form constructor to lookup an individual subscriber.
 */
function findit_subscriber_lookup_form($form, &$form_state) {
  $form['subscriber_id'] = array(
    '#title' => t('Mobile number or e-mail address'),
    '#type' => 'textfield',
    '#size' => 15,
    '#description' => t('Enter the e-mail or mobile number for subscriptions'),
    '#required' => TRUE,
  );
  $form['submit'] = array('#type' => 'submit', '#value' => t('Submit'));
  return $form;
}

/**
 * Form validate callback.
 *
 * @see subscriber_entity_lookup_form()
 */
function findit_subscriber_lookup_form_validate($form, &$form_state) {
  $subscriber_id = $form_state['values']['subscriber_id'];
  $type = findit_subscriber_detect_type($subscriber_id);
  if ($type == 'sms') {
    if($error = findit_subscriber_validate_sms($subscriber_id)) {
      form_set_error($field['field_name'] . '][' . $langcode . '][' . $delta . '][vnid', $error);
    }
    else {
      $form_state['values']['subscriber_id'] = $subscriber_id;
    }
  }
  else {
    if ($error = findit_subscriber_validate_email($subscriber_id)) {
      form_set_error('subscriber_id', $error);
    }
    else {
      $form_state['values']['subscriber_id'] = $subscriber_id;
    }
  }
}

/**
 * Form submit callback.
 *
 * @see subscriber_entity_lookup_form()
 */
function findit_subscriber_lookup_form_submit($form, &$form_state) {
  $subscriber_id = $form_state['values']['subscriber_id'];
  $type = findit_subscriber_detect_type($subscriber_id);

  if ($subscriber = entity_load('subscriber_entity', array($subscriber_id))) {
    $subscriber = reset($subscriber);
    drupal_set_message(t('Subscription loaded'));
    drupal_goto('subscriber/' . $subscriber->id . '/edit');
  }
  else {
    drupal_set_message(t('New subscriber'));
    drupal_set_message(t('%subscriber_id is a new subscription', array('%subscriber_id' => $form_state['values']['subscriber_id'])));
    drupal_goto('subscriber/add/' . $type, array('query' => array('subscriber_id' => $form_state['values']['subscriber_id'])));
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @see subscriber_entity_edit_form()
 */
function findit_subscriber_form_subscriber_entity_edit_form_alter(&$form, &$form_state) {
  $type = $form['#bundle'];
  $bundle = entity_load('subscriber_entity_bundle', array($type));
  $bundle = reset($bundle);
  $field_name = $bundle->unique_field;

  // If this is a new subscription the default is disabled. Responding
  // to confirmation enables.
  if (empty($form['subscriber_id']['#value']) && !subscriber_entity_access('revision')) {
    unset($form['field_subscriber_enabled']);
  }
  // Add default if included in url.
  if (! empty($_GET['subscriber_id'])) {
    if ($type == 'sms') {
      $form[$field_name][LANGUAGE_NONE][0]['#default_value']['vnid'] = check_plain($_GET['subscriber_id']);
    }
    else {
      $form[$field_name][LANGUAGE_NONE][0]['email']['#default_value'] = check_plain($_GET['subscriber_id']);
    }
  }
  $form['#validate'][] = 'findit_subscriber_subscriber_entity_edit_form_validate';
  $form['#submit'][] = $form['actions']['submit']['#submit'][] = 'findit_subscriber_subscriber_entity_edit_form_submit';
  $entity = $form['#entity'];
}

/**
 * Form submission callback.
 *
 * @see findit_subscriber_form_subscriber_entity_edit_form_alter()
 */
function findit_subscriber_subscriber_entity_edit_form_validate(&$form, &$form_state) {
  if (empty($form['subscriber_id']['#value']) && !subscriber_entity_access('revision')) {
    $form_state['values']['field_subscriber_enabled'][LANGUAGE_NONE][0]['value'] = 0;
  }
}


/**
 * Form submission callback.
 *
 * @see findit_subscriber_form_subscriber_entity_edit_form_alter()
 */
function findit_subscriber_subscriber_entity_edit_form_submit($form, &$form_state) {
  if (subscriber_entity_access('revision')) {
    // The user has access to update the revision directly, no additional
    // confirmation required.
    return;
  }

  $subscriber = $form_state['subscriber_entity'];
  // Create an enabled revision if this is the first disabled save.
  if (empty($form['subscriber_id']['#value'])) {
    $subscriber->field_subscriber_enabled['und'][0]['value'] = 1;
    $subscriber->is_new_revision = TRUE;
    $subscriber->default_revision = FALSE;
    $subscriber->save();
  }
  $message = findit_subscriber_request_confirmation($subscriber);
  drupal_set_message($message);
}

/****
 * Helper functions
 */

/**
 * Detect type of subscriber from ID.
 *
 * @param string $subscriber_id
 *
 * @return string
 *   email | sms
 */
function findit_subscriber_detect_type($subscriber_id) {
  return strpos($subscriber_id, '@') ? 'email' : 'sms';
}

/**
 * Check if a SMS mobile number is valid.
 *
 * Also normalizes the subscriber_id parameter.
 * Watch that return it's backward.
 *
 * @param string &$subscriber_id
 *
 * @return bool|string
 *   FALSE if *valid*; error message if not.
 */
function findit_subscriber_validate_sms(&$subscriber_id) {
  // @see voipnumberfield_field_validate().
  $field_info = field_info_field(FINDIT_FIELD_SUBSCRIBER_VOIPNUMBER);
  $subscriber_id = voipnumberfield_format_number($subscriber_id, $field_info['settings']);
  $subscriber_id = VoipCall::NormalizeNumber($subscriber_id);
  $number_country_temp = VoipNumber::getCountryFromNumber($subscriber_id);
  $allowed = FALSE;
  if (!is_array($number_country_temp)) {
    //VoipNumber::getCountryFromNumber can return array of countries or string.
    $number_countries[] = $number_country_temp;
  }
  else {
    $number_countries = $number_country_temp;
  }
  $countries = $field_info['settings']['voipnumberfield_allowed_countries'];
  if (is_array($countries)) {
    // Since $number_countries can be multiple countries we need to check all.
    foreach ($number_countries as $number_country) {
      if (in_array($number_country, $countries)) {
        $allowed = TRUE;
      }
    }
  }

  if (!$allowed) {
    return t('Phone number is not recognized US number.');
  }
  else {
    return FALSE;
  }
}

/**
 * Check if a email address is valid.
 *
 * Watch that return it's backward.
 *
 * @param string &$subscriber_id
 *
 * @return bool|string
 *   FALSE if *valid*; error message if not.
 */
function findit_subscriber_validate_email(&$subscriber_id) {
  // @see email_field_validate().
  if (!valid_email_address(trim($subscriber_id))) {
    return t('"%mail" is not a valid email address', array('%mail' => $subscriber_id));
  }

  return FALSE;
}

/**
 * Create a new subscriber entity.
 *
 * @param string $type
 *   Bundle for the entity sms|email.
 * @param string $subscriber_id
 *   SMS number, or e-mail address.
 *
 * @return Subscriber
 *   Subscriber entity.
 */
function findit_subscriber_create($type, $subscriber_id) {
  $subscriber = entity_get_controller('subscriber_entity')->create(array('bundle' => $type));
  $subscriber->created = time();
  if ($type == 'sms') {
    $subscriber->{FINDIT_FIELD_SUBSCRIBER_VOIPNUMBER}[LANGUAGE_NONE][0]['vnid'] = $subscriber_id;
  }
  else {
    $subscriber->{FINDIT_FIELD_SUBSCRIBER_EMAIL}[LANGUAGE_NONE][0]['email'] = $subscriber_id;
  }

  return $subscriber;
}

/**
 * Send confirmation message.
 *
 * Written in this slightly abstract way as lead to generalize into subscriber entity
 * module.
 * Todo move into parent module.
 */
function findit_subscriber_request_confirmation($subscriber) {
  $bundle = entity_load('subscriber_entity_bundle', array($subscriber->bundle));
  $bundle = reset($bundle);
  $field_name = $bundle->unique_field;

  $callback = 'findit_subscriber_request_confirmation_' . $subscriber->bundle;
  return $callback($subscriber, $field_name);
}

/**
 * Send SMS confirmation message.
 */
function findit_subscriber_request_confirmation_sms($subscriber, $field) {
  // Force a reload of subscriber entity, because at the moment the vnid is set
  // as the vnid rather than the 'real_vnid' and the number is missing.
  $subscriber_array = entity_load('subscriber_entity', array($subscriber->id), array(), TRUE);
  $subscriber = reset($subscriber_array);

  // Send confirmation SMS.
  $voipnumbers = field_get_items('subscriber_entity', $subscriber, $field);
  $number_render = field_view_value('subscriber_entity', $subscriber, $field, $voipnumbers[0]);
  $number = $number_render['#markup'];
  $call = new VoipCall();
  $call->setDestNumber($number);
  $text = t('Your subscription has been updated. Reply to this message with YES if you would like to confirm the changes.');
  voip_text($text, $call);
  return t('A SMS has been sent to your phone for confirmation.');
}

/**
 * Send confirmation email.
 */
function findit_subscriber_request_confirmation_email($subscriber, $field) {
  drupal_mail(
    'findit_subscriber',
    'confirmation',
    $subscriber->{$field}[LANGUAGE_NONE][0]['email'],
    language_default(),
    array(
      'url' => findit_subscriber_email_confirmation_url($subscriber),
    )
  );
  return t('An email has been sent for confirmation.');
}


/**
 * Mail callback for confirmation message.
 *
 * @see findit_subscriber_mail()
 */
function findit_subscriber_confirmation_mail(&$message, $url) {
  $langcode = $message['language']->language;
  $message['subject'] = t(
    'Find It subscription confirmation',
    array(),
    array('langcode' => $langcode)
  );
  $message['body'][] = t(
    'Please visit !url to confirm your subscription.',
    array('!url' => $url),
    array('langcode' => $langcode)
  );
}

/****
 * Confirmation handling.
 *
 * Confirmation can be called from incoming SMS, or from clicking
 * on a link in the email.
 *
 * @todo this could be moved on up as available api functions in
 * entity subscriber.
 */

/**
 * Menu access callback: subscription confirmation.
 */
function findit_subscriber_confirm_page_access($revision_id, $hash) {
  // Todo When moved into subscriber entity add a user check.
  // Find It we know anyone can access, as long as URL is correct.
  if (!($revision = entity_revision_load('subscriber_entity', $revision_id))) {
    return FALSE;
  }
  if ($hash != findit_subscriber_generate_hash($revision)) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Menu callback; confirmation page for subscriptions.
 */
function findit_subscriber_confirm_page($revision_id) {
  $revision = entity_revision_load('subscriber_entity', $revision_id);
  if ($revision->default_revision) {
    return t('Subscription already confirmed.');
  }
  else {
    entity_revision_set_default('subscriber_entity', $revision);
    $revision->save();
    return t('Subscription %title has been confirmed.', array('%title' => $revision->subscriber_id));
  }
}

/**
 * Callback to update revision.
 */
function findit_subscriber_revision_update($caller_number) {
  // Extra space is casting workaround, we know it's a string.
  $subscription = subscriber_entity_load(' ' . $caller_number, 'sms');

  $entity_info = entity_get_info('subscriber_entity');
  $id = $entity_info['entity keys']['id'];
  $revision_key = $entity_info['entity keys']['revision'];
  $revision_table = $entity_info['revision table'];

  // Fetch latest updated revision.
  $revision = db_select($revision_table, 'r')
    ->fields('r')
    ->condition($id, $subscription->$id, '=')
    ->orderBy('changed', 'DESC')
    ->orderBy('revision_id', 'DESC')
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();

  // If no revision _how_?
  if (!$revision) {
    return FALSE;
  }

  // If the present revision is the latest don't do anything.
  if ($revision[$revision_key] == $subscription->$revision_key) {
    return $subscription;
  }

  // Make the latest revision the default one.
  $new_subscription = entity_revision_load('subscriber_entity', $revision[$revision_key]);
  entity_revision_set_default('subscriber_entity', $new_subscription);
  $new_subscription->save();
  return $new_subscription;
}

function findit_subscriber_email_confirmation_url($entity_revision) {
  return url(
    'subscription/confirm/' . $entity_revision->revision_id . '/' . findit_subscriber_generate_hash($entity_revision),
    array('absolute' => TRUE)
  );
}

function findit_subscriber_generate_hash($entity, $action = 'confirm') {
  return drupal_hash_base64(
    $entity->subscriber_id
    . $entity->revision_id
    . findit_subscriber_private_key()
    . $action
    . $entity->changed
  );
}

function findit_subscriber_private_key() {
  if (!($key = variable_get('findit_subscriber_private_key', 0))) {
    $key = drupal_random_key();
    variable_set('findit_subscriber_private_key', $key);
  }
  return $key;
}


/****
 * Send notifications.
 *
 * Regular cron job to trigger sending SMS and email notifications for the site
 * specific messages (presently just events).
 */

/**
 * Implements hook_cron().
 */
function findit_subscriber_cron() {
  $last_run = variable_get('findit_subscriber_cron_run', '@0');
  $last_run_date = new DateTime($last_run);
  $yesterday = new DateTime('yesterday');
  $now = new DateTime();
  // Run notifications if they were last sent yesterday (or earlier),
  // and it is after 4 in the afternoon.
  if ($last_run_date <= $yesterday && $now->format('H') > 15) {
    findit_subscriber_notify_tomorrow();
    variable_set('findit_subscriber_cron_run', $now->format('Y-m-d'));
  }
}

/**
 * Implements hook_form_alter().
 *
 * Add option to choose if notification of creation/update is sent.
 */
function findit_subscriber_form_alter(&$form, &$form_state, $form_id) {
  if (!in_array($form_id, array('event_node_form'))) {
    return;
  }

  $new = empty($form['nid']['#value']);
  if ($new && $form['#bundle'] == 'event') {
    // No one can have subscribed to an event before it is created.
    return;
  }

  if ($new) {
    $checkbox_title = t('Send notifications about this new announcement');
  }
  else {
    $checkbox_title = t('Send notifications about this update');
  }
  $form['findit_subscriber_notification'] = array(
    '#type' => 'fieldset',
    '#access' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
    '#title' => t('Notifications'),
  );
  $form['findit_subscriber_notification']['findit_subscriber_notification_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => $checkbox_title,
    '#default_value' => 1,
  );
}

/**
 * Implements hook_node_update().
 */
function findit_subscriber_node_update($node) {
  if (!empty($node->findit_subscriber_notification_enabled) && $node->status) {
    if ($node->type == 'event') {
      $subscribers = findit_subscriber_event_subscribers($node->nid);
      foreach ($subscribers as $subscriber) {
        if ($subscriber->bundle == 'sms') {
          findit_subscriber_queue_sms($subscriber, t('Details of event @title have been updated', array('@title' => $node->title)));
        }
        else {
          drupal_mail(
            'findit_subscriber',
            'event_post_notification',
            $subscriber->{FINDIT_FIELD_SUBSCRIBER_EMAIL}[LANGUAGE_NONE][0]['email'],
            language_default(),
            array(
              'node' => $node,
              'action' => 'update',
            )
          );
        }
      }
    }
  }
}

/**
 * Notify subscribers of tomorrows events.
 */
function findit_subscriber_notify_tomorrow() {
  $events = findit_subscriber_events_upcoming();
  foreach ($events as $event) {
    $subscribers = findit_subscriber_event_subscribers($event->nid);
    foreach ($subscribers as $subscriber) {
      $notifications[$subscriber->bundle][$subscriber->subscriber_id]['subscriber'] = $subscriber;
      $notifications[$subscriber->bundle][$subscriber->subscriber_id]['events'][] = $event;
    }
  }

  if (!empty($notifications['sms'])) {
    // Just send one text message per event to subscribers.
    foreach ($notifications['sms'] as $notification) {
      $subscriber = $notification['subscriber'];
      foreach ($notification['events'] as $event) {
        findit_subscriber_queue_sms($subscriber, t('Reminder. Tomorrow @title', array('@title' => $event->title)));
      }
    }
  }

  if (!empty($notifications['email'])) {
    foreach ($notifications['email'] as $notification) {
      $subscriber = $notification['subscriber'];
      drupal_mail(
        'findit_subscriber',
        'event_notification',
        $subscriber->{FINDIT_FIELD_SUBSCRIBER_EMAIL}[LANGUAGE_NONE][0]['email'],
        language_default(),
        array(
          'events' => $notification['events'],
        )
      );
    }
  }
}

/**
 * Mail callback for event notification.
 *
 * @see findit_subscriber_mail()
 */
function findit_subscriber_event_notify_mail(&$message, $events) {
  $langcode = $message['language']->language;
  $message['subject'] = t(
    'Find IT events tomorrow',
    array(),
    array('langcode' => $langcode)
  );
  $message['body'][] = format_plural(
    count($events),
    'An event you requested notification for happens tomorrow:',
    'Events you requested a notification for happen tomorrow:',
    array(),
    array('langcode' => $langcode)
  );
  foreach($events as $event) {
    $event_time_value = field_get_items('node', $event, FINDIT_FIELD_EVENT_DATE);
    $event_time_render = field_view_value(
      'node',
      $event,
      FINDIT_FIELD_EVENT_DATE,
      $event_time_value[0],
      array(
        'label' => 'hidden',
        // You can't set date_plain format settings ...
        // 'type' => 'date_plain',
        'settings' => array(
          'format_type' => 'medium',
          'show_remaining_days' => FALSE,
          'show_repeat_rule'    => 'show',
        ),
      ),
      $langcode
    );
    // ... However Date default puts in HTML. Bah!
    $event_time = strip_tags($event_time_render['#markup']);
    $message['body'][] = t(
      '@time : @title - !url',
      array(
        '@title' => $event->title,
        '@time' => $event_time,
        '!url' => url('node/' . $event->nid, array('absolute' => TRUE)),
      ),
      array('langcode' => $langcode)
    );
  }
}

/**
 * Mail callback for posting notification.
 *
 * @see findit_subscriber_mail()
 */
function findit_subscriber_post_notify_mail(&$message, $node, $action) {
  $langcode = $message['language']->language;
  if ($node->type == 'event') {
    $message['subject'] = t(
      'Find IT event @title has been updated',
      array('@title' => $node->title),
      array('langcode' => $langcode)
    );
  }
  $message['body'][] = t(
    'Full @type at !url',
    array(
      '@type' => $node->type,
      '!url' => url('node/' . $node->nid, array('absolute' => TRUE)),
    ),
    array('langcode' => $langcode)
  );
  if ($node->type == 'event') {
    $event_time_value = field_get_items('node', $node, FINDIT_FIELD_EVENT_DATE);
    $event_time_render = field_view_value(
      'node',
      $node,
      FINDIT_FIELD_EVENT_DATE,
      $event_time_value[0],
      array(
        'label' => 'hidden',
        // You can't set date_plain format settings ...
        // 'type' => 'date_plain',
        'settings' => array(
          'format_type' => 'medium',
          'show_remaining_days' => FALSE,
          'show_repeat_rule'    => 'show',
        ),
      ),
      $langcode
    );
    // ... However Date default puts in HTML. Bah!
    $event_time = strip_tags($event_time_render['#markup']);
    $message['body'][] = t(
      'Event date: @time',
      array(
        '@time' => $event_time,
      ),
      array('langcode' => $langcode)
    );
  }
  $message['body'][] = check_plain($node->body[LANGUAGE_NONE][0]['value']);
}


/**
 * Get array of all subscribers entities to an event node.
 */
function findit_subscriber_event_subscribers($nid) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'subscriber_entity');
  $query->fieldCondition(FINDIT_FIELD_SUBSCRIBER_EVENTS, 'target_id', $nid, '=');
  $query->fieldCondition(FINDIT_FIELD_SUBSCRIBER_ENABLED, 'value', 1, '=');
  $result = $query->execute();
  if (isset($result['subscriber_entity'])) {
    $ids = array_keys($result['subscriber_entity']);
  }
  else {
    $ids = array();
  }
  return entity_load('subscriber_entity', $ids);
}

/**
 * Get array of all tomorrows event nodes.
 *
 * Todo swap this to use its own view, or EFQ.
 */
function findit_subscriber_events_upcoming() {
  $tomorrow = new DateTime('tomorrow');
  $view = views_get_view('event_calendar');
  if (!$view) {
    // Should only happen before the site is fully initialized.
    watchdog('findit_subscriber', 'Missing view: Event calendar', array(), WATCHDOG_WARNING);
    return array();
  }
  $view->set_display('page_3');
  $view->set_arguments(array($tomorrow->format('Y-m-d')));
  $view->pre_execute();
  $view->execute();
  // Just because this is lazy using an existing field based view.
  $results = array();
  foreach ($view->result as $result) {
    $results[] = $result->_field_data['nid']['entity'];
  }
  return $results;
}

/**
 * Queue an SMS.
 */
function findit_subscriber_queue_sms($subscriber, $text, $queue = 'findit_notification') {
  $queue = DrupalQueue::get('findit_notification');
  $queue->createQueue();
  $call = new VoipCall(array());
  $number_items = field_get_items('subscriber_entity', $subscriber, FINDIT_FIELD_SUBSCRIBER_VOIPNUMBER);
  $number_render = field_view_value('subscriber_entity', $subscriber, FINDIT_FIELD_SUBSCRIBER_VOIPNUMBER, $number_items[0]);
  $call->setDestNumber($number_render['#markup']);
  $item = new VoipQueueText($call, $text);
  $item->tags = array('findit:' . $subscriber->id);
  $queue->createItem($item);
}
